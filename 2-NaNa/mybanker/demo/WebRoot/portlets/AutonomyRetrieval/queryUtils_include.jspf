<%@ page import="java.util.ArrayList,
                 java.util.Iterator,
                 java.util.List,

                 com.autonomy.APSL.PortalService,
                 com.autonomy.APSL.ServiceFactory,
                 com.autonomy.portlet.constants.RetrievalConstants,
                 com.autonomy.portlet.resultpages.BatchedResultPages,
                 com.autonomy.portlet.resultpages.QueryResultPages,

                 com.autonomy.aci.ActionParameter,
                 com.autonomy.aci.businessobjects.ResultList,
                 com.autonomy.aci.businessobjects.User,
                 com.autonomy.aci.constants.IDOLConstants,
                 com.autonomy.aci.exceptions.AciException,
                 com.autonomy.aci.services.IDOLService,
                 com.autonomy.webapps.utils.parametric.ParametricFieldInfo,
                 com.autonomy.webapps.utils.querysummary.QSE,
                 com.autonomy.webapps.utils.querysummary.tree.QSClusterTree,
                 com.autonomy.webapps.utils.querysummary.tree.QSCluster,
                 com.autonomy.webapps.utils.querysummary.tree.QSClusterPath,
                 com.autonomy.webapps.utils.querysummary.cloud.QSIdeasCloud" %><%!

// Performs the query and saves the results on the session
private static void doQuery(PortalService service)
{
	IDOLService idol = service.getIDOLService();
	if(idol != null)
	{
		int batchSize = StringUtils.atoi(getRequestParam(service, RetrievalConstants.REQUEST_PARAM_NUM_RESULTS), 6);
		// See queryUtils_include.jspf for getQueryActionParameters
		ArrayList queryParameters = getQueryActionParameters(service);

		BatchedResultPages resultPages = new QueryResultPages(service, queryParameters, batchSize);

		service.setSessionAttribute(RetrievalConstants.SESSION_ATTRIB_RESULT_HITS, resultPages);
	}
	else
	{
		setError(service, "Could not perform query as no IDOL service is available.");
	}
}

// Returns the ArrayList of ActionParameters required for a query. The method will save it on the session and keep using
// the saved copy until it is set to null. This allows the Dynamic Thesaurus to use them when retrieving results.
private static ArrayList getQueryActionParameters(PortalService service)
{
	// Try to use the parameters that are saved on the session if there are any
	ArrayList queryParameters = (ArrayList)service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_LAST_QUERY_PARAMS);

	if(queryParameters == null)
	{
		queryParameters = convertQueryFormToActionParameters(service);

		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_QUERY_SUMMARY_PARAM_NAME,   service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_QUERY_SUMMARY, "false")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_SUMMARY_PARAM_NAME,         service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_SUMMARY, "context")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_SENTENCES_PARAM_NAME,       service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_SENTENCES, "3")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_CHARACTERS_PARAM_NAME,      service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_CHARACTERS, "300")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_PRINT_PARAM_NAME,           service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_PRINT, "none")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_PRINT_FIELDS_PARAM_NAME,    service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_PRINT_FIELDS, "")));
		queryParameters.add(new ActionParameter(IDOLConstants.XML_META_PARAM_NAME,              service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_XML_META, "true")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_COMBINE_PARAM_NAME,         service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_COMBINE, "simple")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_OUTPUT_ENCODING_PARAM_NAME, service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_OUTPUT_ENCODING, "utf8")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_ANY_LANGUAGE_PARAM_NAME,	service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_ANY_LANGUAGE, "false")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_SPELLCHECK_PARAM_NAME,      service.readConfigParameter(RetrievalConstants.CONFIG_PARAM_SPELL_CHECK, "false")));

		service.setSessionAttribute(RetrievalConstants.SESSION_ATTRIB_LAST_QUERY_PARAMS, queryParameters);
	}

	return queryParameters;
}

// Generates an ArrayList of all the query-specific ActionParameters
private static ArrayList convertQueryFormToActionParameters(PortalService service)
{
	ArrayList queryParameters = new ArrayList();

	queryParameters.add(new ActionParameter(IDOLConstants.TEXT_PARAM_NAME,                getRequestParam(service, RetrievalConstants.REQUEST_PARAM_QUERY_TEXT)));
	queryParameters.add(new ActionParameter(IDOLConstants.QUERY_MIN_SCORE_PARAM_NAME,     getRequestParam(service, RetrievalConstants.REQUEST_PARAM_THRESHOLD)));
	queryParameters.add(new ActionParameter(IDOLConstants.QUERY_LANGUAGE_TYPE_PARAM_NAME, getRequestParam(service, RetrievalConstants.REQUEST_PARAM_QUERY_LANGUAGE)));
	queryParameters.add(new ActionParameter(IDOLConstants.QUERY_SORT_PARAM_NAME,          getRequestParam(service, RetrievalConstants.REQUEST_PARAM_SORT_BY)));
	queryParameters.add(new ActionParameter(IDOLConstants.QUERY_SECURITY_INFO_PARAM_NAME, ((User)service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_USER)).getSecurityInfo()));

	String[] infoSources = service.getRequestParameterValues(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_INFO_SOURCES));

	if(infoSources != null && infoSources.length > 0)
	{
		queryParameters.add(new ActionParameter("DatabaseMatch", StringUtils.combine(infoSources, "+")));
	}

	if(StringUtils.isTrue(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_DATE), "false")))
	{
		queryParameters.add(new ActionParameter("MinDate", getMinDate(service)));
		queryParameters.add(new ActionParameter("MaxDate", getMaxDate(service)));
	}

	// parametric field restrictions
	String fieldText = buildFieldTextParameter(service);
	if(StringUtils.strValid(fieldText))
	{
		queryParameters.add(new ActionParameter("FieldText", fieldText));
	}

	return queryParameters;
}

private static String getMinDate(PortalService service)
{
	StringBuffer minDate = new StringBuffer();
	minDate.append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_FROM_DAY), ""))
	       .append("/")
	       .append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_FROM_MONTH), ""))
	       .append("/")
	       .append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_FROM_YEAR), ""));
	return minDate.toString();
}

private static String getMaxDate(PortalService service)
{
	StringBuffer maxDate = new StringBuffer();
	maxDate.append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_TO_DAY), ""))
	       .append("/")
	       .append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_TO_MONTH), ""))
	       .append("/")
           .append(service.getSafeRequestParameter(service.makeParameterName(RetrievalConstants.REQUEST_PARAM_USE_TO_YEAR), ""));
	return maxDate.toString();
}

private static String buildFieldTextParameter(PortalService service)
{
	StringBuffer fieldText = new StringBuffer();

	if(service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_PARAMETRIC_INFO) != null)
	{
		boolean isFirstField = true;
		Iterator parametricFields = ((List)service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_PARAMETRIC_INFO)).iterator();
		while(parametricFields.hasNext())
		{
			ParametricFieldInfo fieldInfo = (ParametricFieldInfo)parametricFields.next();
			String selectedFieldValue = getRequestParam(service, RetrievalConstants.REQUEST_PARAM_PARAM_FIELD_PREFIX + fieldInfo.getDisplayName());
			if(StringUtils.strValid(selectedFieldValue))
			{
				fieldInfo.setSelectedValue(selectedFieldValue);
				// don't send default selection choice
				if(!selectedFieldValue.equals(service.readConfigParameter("ParametricField.topentry", "--- Select ---")))
				{
					if(isFirstField)
					{
						isFirstField = false;
					}
					else
					{
						fieldText.append("+AND+");
					}
					fieldText.append("MATCH{").append(selectedFieldValue).append("}:*/").append(fieldInfo.getIDOLFieldName());
				}
			}
		}
	}

	return fieldText.toString();
}

// Dynamic Thesaurus: Generate a QSClusterTree object containing the initial thesaurus for a query
private static QSClusterTree getInitialDynamicThesaurusTree(PortalService service) throws AciException
{
	// Clear the previous tree to prevent getDynamicThesaurusSubClusters using it
	service.setSessionAttribute("QuerySummaryTree", null);

	QSCluster clusterRoot = generateClusterRoot(service);

	clusterRoot = getDynamicThesaurusSubClusters(service, clusterRoot);

	return new QSClusterTree(clusterRoot);
}

// Expands a cluster for Dynamic Thesaurus
private static void expandThesaurus(PortalService service, String path) throws AciException
{
	QSCluster clusterToExpand = getExpansionCluster(service, path);

	if(clusterToExpand != null)
	{
		getDynamicThesaurusSubClusters(service, clusterToExpand);
	}
}

// Dynamic Thesaurus: If the children of parentCluster aren't already known, go and get them from IDOL
private static QSCluster getDynamicThesaurusSubClusters(PortalService service, QSCluster parentCluster) throws AciException
{
	QSClusterPath clusterPath = new QSClusterPath(parentCluster.getClusterPath());

	if(!parentCluster.isSubClustered() && clusterPath.depth() <= getMaxClusterDepth(service))
	{
		ArrayList alQuerySummary = new ArrayList();

		ResultList clusterResults = doClusterQuery(service, parentCluster);
		// Generate an array of all the <autn:qs><autn:element ...> results
		QSE qse[] = QSE.generateElementArray(clusterResults);

		if(qse.length > 0)
		{
			qse = QSE.removeNegativeClusters(qse);

			// Attempt to remove children with the same names as their parents
			QSClusterTree tree = (QSClusterTree)service.getSessionAttribute("QuerySummaryTree");

			if(tree != null)
			{
				QSCluster root = tree.getRootCluster();

				if(root != null)
				{
					String[] clusterPathArray = root.getNamePathAsArray(new QSClusterPath(parentCluster.getClusterPath()));

					if(clusterPathArray != null)
					{
						for(int nLoop = 0 ; nLoop < clusterPathArray.length ; nLoop++)
						{
							qse = QSE.removeElementsByValue(qse, clusterPathArray[nLoop]);
						}
					}
				}
			}

			// Build the thesaurus
			for(int nLoop = 0 ; nLoop < qse.length ; nLoop++)
			{
				alQuerySummary.add(qse[nLoop].getValue());
			}
		}
		else
		{
			// Attempt to use <autn:querysummary> tags instead
			alQuerySummary = clusterResults.getQuerySummary();
		}

		for(int nLoop = 0 ; nLoop < alQuerySummary.size() && nLoop < getMaxThesaurusSize(service) ; nLoop++)
		{
			QSCluster subCluster = new QSCluster();
			subCluster.setName((String)alQuerySummary.get(nLoop));
			subCluster.setClusterPath(new StringBuffer(parentCluster.getClusterPath()).append(QSClusterPath.PATH_SEPARATOR).append(nLoop).toString());
			subCluster.setSubClustered(!(clusterPath.depth() < getMaxClusterDepth(service)));
			parentCluster.addChild(subCluster);
		}
		parentCluster.setSubClustered(true);
	}
	return parentCluster;
}

// Dynamic Clustering: Generate a QSClusterTree object containing the initial clusters for a query
private static QSClusterTree getInitialDynamicClusteringTree(PortalService service) throws AciException
{
	// Clear the previous tree to prevent it being used
	service.setSessionAttribute("QuerySummaryTree", null);

	// construct a root for the cluster expansion tree
	QSCluster clusterRoot = generateClusterRoot(service);
	clusterRoot.setSubClustered(true);

	ResultList clusterResults = doClusterQuery(service, clusterRoot);

	clusterRoot.populateFromResultList(clusterResults);

	// If there is only one cluster, 'Other', then don't bother
	if(clusterRoot.getChildren().size() == 1)
	{
		clusterRoot.setChildren(new ArrayList(0));
	}

	// See if any of the immediate subclusters can be further clustered
	Iterator subClusters = clusterRoot.getChildren().iterator();

	while(subClusters.hasNext())
	{
		QSCluster subCluster = (QSCluster)subClusters.next();

		// filter out the subcluster containing all the documents not in the real subclusters
		if(!subCluster.getName().equals(clusterRoot.getName()))
		{
			getDynamicClusteringSubClusters(service, subCluster, false);
		}
	}

	return new QSClusterTree(clusterRoot);
}

// Dynamic Clustering: Expands a cluster
private static void expandCluster(PortalService service, String path) throws AciException
{
	QSCluster clusterToExpand = getExpansionCluster(service, path);

	if(clusterToExpand != null)
	{
		// try to subcluster this cluster

		getDynamicClusteringSubClusters(service, clusterToExpand, true);

		// and see if any of its immediate subclusters can be further clustered

		Iterator subClusters = clusterToExpand.getChildren().iterator();
		while(subClusters.hasNext())
		{
			QSCluster subCluster = (QSCluster)subClusters.next();
			// filter out the subcluster containing all the documents not in the real subclusters as this should
			// never be clustered
			if(!subCluster.getName().equals(clusterToExpand.getName()))
			{
				getDynamicClusteringSubClusters(service, subCluster, false);
			}
		}
	}
}

// Dynamic Clustering: If the children of parentCluster aren't already known, go and get them from IDOL
// The method tries to work out whether or not it is necessary to send the query to IDOL. Use forceCheck = true to force the issue.
private static QSCluster getDynamicClusteringSubClusters(PortalService service, QSCluster parentCluster, boolean forceCheck) throws AciException
{
	QSClusterPath clusterPath = new QSClusterPath(parentCluster.getClusterPath());
	if(clusterPath.depth() <= getMaxClusterDepth(service) || forceCheck)
	{
		if(parentCluster.getNumResultDocs() < getMaxNumDocsForSubClustering(service) || forceCheck)
		{
			if((parentCluster.getNumResultDocs() >= getMinNumDocsForSubClustering(service) || forceCheck) && !parentCluster.isSubClustered())
			{
				ResultList subClusterResults = doClusterQuery(service, parentCluster);
				parentCluster.populateFromResultList(subClusterResults);
			}
			parentCluster.setSubClustered(true);
		}
	}
	else
	{
		parentCluster.setSubClustered(true);
	}
	return parentCluster;
}

private static QSClusterTree getInitialAQGTree(PortalService service) throws AciException
{
	QSCluster clusterRoot = generateClusterRoot(service);

	ResultList clusterResults = doClusterQuery(service, null);

	// Generate an array of all the <autn:qs><autn:element ...> results
	QSE qse[] = QSE.generateElementArray(clusterResults);

	qse = QSE.removeNegativeClusters(qse);

	ArrayList alClusterIDs = new ArrayList();

	for(int nLoop = 0 ; nLoop < qse.length ; nLoop++)
	{
		Integer currentID = new Integer(qse[nLoop].getCluster());

		int index = alClusterIDs.indexOf(currentID);

		if(index == -1)
		{
			if(alClusterIDs.size() < getMaxNumAQGClusters(service))
			{
				alClusterIDs.add(currentID);

				QSCluster subCluster = new QSCluster();
				subCluster.setName(qse[nLoop].getValue());
				subCluster.setClusterPath("0+" + (alClusterIDs.size() - 1));
				subCluster.setSubClustered(false);
				clusterRoot.addChild(subCluster);
			}
		}
		else
		{
			QSCluster parentCluster = clusterRoot.findSubCluster(new QSClusterPath("0+" + index));

			if(parentCluster.getChildren().size() < getMaxAQGClusterSize(service) - 1)
			{
				QSCluster subCluster = new QSCluster();
				subCluster.setName(qse[nLoop].getValue());
				subCluster.setClusterPath(new StringBuffer(parentCluster.getClusterPath()).append(QSClusterPath.PATH_SEPARATOR).append(parentCluster.getChildren().size()).toString());
				subCluster.setSubClustered(true);
				parentCluster.addChild(subCluster);
				parentCluster.setExpanded(true);
				parentCluster.setSubClustered(true);
			}
		}
	}

	return new QSClusterTree(clusterRoot);
}

private static QSIdeasCloud getInitialIdeasCloud(PortalService service) throws AciException
{
	ResultList clusterResults = doClusterQuery(service, null);

	// Generate an array of all the <autn:qs><autn:element ...> results
	QSE qse[] = QSE.generateElementArray(clusterResults);

	qse = QSE.removeNegativeClusters(qse);

	int maxIdeas = getMaxIdeasCloudDroplets(service);

	QSIdeasCloud cloud = new QSIdeasCloud(qse, maxIdeas);

	// Save the initial concept for building later queries
	cloud.setConcept(getRequestParam(service, RetrievalConstants.REQUEST_PARAM_QUERY_TEXT));
	cloud.sort();

	return cloud;
}

// Dynamic Thesaurus, Dynamic Clustering & AQG: Performs the querysummary query relevant to a particular cluster
private static ResultList doClusterQuery(PortalService service, QSCluster cluster) throws AciException
{
	ArrayList queryParameters = getQuerySummaryActionParameters(service);

	if(cluster != null)
	{
		// restrict search to given document list
		String clusterDocsCSV = cluster.getDocRefsSV();

		if(StringUtils.strValid(clusterDocsCSV))
		{
			replaceActionParameter(queryParameters, IDOLConstants.QUERY_MATCH_ID_PARAM_NAME, clusterDocsCSV);
			replaceActionParameter(queryParameters, IDOLConstants.QUERY_MAX_RESULTS_PARAM_NAME, cluster.getDocReferences().size());
		}
		else
		{
			replaceActionParameter(queryParameters, IDOLConstants.QUERY_MAX_RESULTS_PARAM_NAME, getNumClusterResults(service));
		}

		replaceActionParameter(queryParameters, IDOLConstants.TEXT_PARAM_NAME, buildThesaurusQueryText(service, cluster.getClusterPath()));
	}
	else
	{
		// Would like all the results back so we can have accurate numbers on how many documents
		// each cluster contains (if query is not limited to a given set of documents)
		replaceActionParameter(queryParameters, IDOLConstants.QUERY_MAX_RESULTS_PARAM_NAME, getNumClusterResults(service));
	}

	ResultList rl = null;

	IDOLService idol = service.getIDOLService();

	if(idol != null)
	{
		rl = idol.useConceptRetrievalFunctionality().doQuery(queryParameters);
	}

	return rl;
}

// Dynamic Clustering: Retrieves the results for a cluster
private static BatchedResultPages retrieveQSClusterDocuments(PortalService service, String path) throws AciException
{
	BatchedResultPages resultPages = null;

	QSClusterPath clusterPath = new QSClusterPath(path);

	QSClusterTree qsClusterTree = (QSClusterTree)service.getSessionAttribute("QuerySummaryTree");

	IDOLService idol = service.getIDOLService();

	if(qsClusterTree != null && idol != null)
	{
		QSCluster clusterToDisplay = qsClusterTree.findCluster(clusterPath);

		if(clusterToDisplay != null)
		{
			ArrayList parameters = (ArrayList)service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_LAST_QUERY_PARAMS);

			replaceActionParameter(parameters, "matchid", clusterToDisplay.getDocRefsSV());

			QSCluster root = getRootCluster(service);

			if(root != null)
			{
				replaceActionParameter(parameters, "text", root.getName());
			}

			int batchSize = 6;

			try
			{
				Integer.parseInt(getRequestParam(service, RetrievalConstants.REQUEST_PARAM_NUM_RESULTS));
			}
			catch(Exception e)
			{
			}

			resultPages = new QueryResultPages(service, parameters, batchSize);
		}
	}

	return resultPages;
}

// Returns the ArrayList of ActionParameters required for a querysummary. The method will save it on the session and keep using
// the saved copy until it is set to null. This allows Dynamic Clustering to reuse them for subclustering.
private static ArrayList getQuerySummaryActionParameters(PortalService service)
{
	// Try to use the parameters that are saved on the session if there are any
	ArrayList queryParameters = (ArrayList)service.getSessionAttribute("QuerySummaryActionParameters");

	if(queryParameters == null)
	{
		queryParameters = convertQueryFormToActionParameters(service);

		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_QUERY_SUMMARY_PARAM_NAME,   service.readConfigParameter("QS.QuerySummary", "true")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_PRINT_PARAM_NAME,           service.readConfigParameter("QS.Print", "noresults")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_COMBINE_PARAM_NAME,         service.readConfigParameter("QS.Combine", "simple")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_OUTPUT_ENCODING_PARAM_NAME, service.readConfigParameter("QS.OutputEncoding", "utf8")));
		queryParameters.add(new ActionParameter(IDOLConstants.QUERY_ANY_LANGUAGE_PARAM_NAME,	service.readConfigParameter("QS.ResultsInAnyLanguage", "false")));

		service.setSessionAttribute("QuerySummaryActionParameters", queryParameters);
	}

	return queryParameters;
}

// Dynamic Thesaurus & Dynamic Clustering: Constructs the query text for a particular node
private static String buildThesaurusQueryText(PortalService service, String path)
{
	// e.g. Original query: vulcan
	//      Path:           vulcan+Star Trek
	//      Query text:     (vulcan) AND (Star Trek)
	// Note that this form prevents 'vulcan', 'Star' and 'Trek' from being children.
	// We have to remove 'Star Trek' from the list ourselves.

	String[] clusterPathArray = getNamePathAsArray(service, path);

	if(clusterPathArray != null && clusterPathArray.length > 0)
	{
		StringBuffer sbQueryText = new StringBuffer("(" + clusterPathArray[0] + ")");

		for(int nLoop = 1 ; nLoop < clusterPathArray.length ; nLoop++)
		{
			sbQueryText.append(" AND (").append(clusterPathArray[nLoop]).append(")");
		}

		return sbQueryText.toString();
	}

	return null;
}

// AQG: Constructs the query text for a particular node
private static String buildAQGQueryText(PortalService service, String path)
{
	// The desired form is:
	// (original query)+AND+((AQG1)+OR+(AQG2)+OR+...)

	QSClusterTree tree = (QSClusterTree)service.getSessionAttribute("AQGTree");

	if(tree != null)
	{
		// This cluster should be a first-generation child of the root but use findCluster anyway
		QSCluster cluster = tree.findCluster(new QSClusterPath(path));

		if(cluster != null)
		{
			StringBuffer sbQueryText = new StringBuffer("(" + tree.getRootCluster().getName() + ")");

			sbQueryText.append("+AND+((").append(cluster.getName());

			ArrayList children = cluster.getChildren();

			for(int childIndex = 0 ; childIndex < children.size() ; childIndex++)
			{
				cluster = (QSCluster)children.get(childIndex);

				sbQueryText.append(")+OR+(").append(cluster.getName());
			}

			sbQueryText.append("))");

			return sbQueryText.toString();
		}
	}

	return null;
}

private static String buildIdeasCloudQueryText(PortalService service, String path)
{
	QSIdeasCloud cloud = (QSIdeasCloud)service.getSessionAttribute("IdeasCloud");

	if (cloud != null)
	{
		return "(" + cloud.getConcept() + ") AND (" + path + ")";
	}

	return null;
}

// Dynamic Clustering & Dynamic Thesaurus: Prepares a cluster for expansion
private static QSCluster getExpansionCluster(PortalService service, String path)
{
	QSCluster clusterToExpand = null;

	QSClusterTree qsClusterTree = (QSClusterTree)service.getSessionAttribute("QuerySummaryTree");

	if(qsClusterTree != null && path != null)
	{
		clusterToExpand = qsClusterTree.findCluster(new QSClusterPath(path));

		if(clusterToExpand != null)
		{
			clusterToExpand.setExpanded(true);
		}
	}

	return clusterToExpand;
}

// Convenience method to generate a suitable root node for either Dynamic Thesaurus or Dynamic Clustering
private static QSCluster generateClusterRoot(PortalService service)
{
	String queryText = getRequestParam(service, RetrievalConstants.REQUEST_PARAM_QUERY_TEXT);

	QSCluster clusterRoot = new QSCluster();
	clusterRoot.setName(queryText);
	clusterRoot.setClusterPath("0");
	clusterRoot.setExpanded(true);
	clusterRoot.setIsRootCluster(true);
	clusterRoot.setMinClusterSize(getMinClusterSize(service));

	return clusterRoot;
}

// Convenience method to get a String[] of node names along a path
// e.g. path = "0+0" might return {"vulcan", "Star Trek"}
private static String[] getNamePathAsArray(PortalService service, String path)
{
	QSCluster root = getRootCluster(service);

	if(root != null)
	{
		return root.getNamePathAsArray(new QSClusterPath(path));
	}

	return null;
}

// Convenience method to get the root cluster for the querysummary tree
private static QSCluster getRootCluster(PortalService service)
{
	QSClusterTree tree = (QSClusterTree)service.getSessionAttribute("QuerySummaryTree");

	if(tree != null)
	{
		return tree.getRootCluster();
	}

	return null;
}

private static int getMaxThesaurusSize(PortalService service)
{
	return readIntConfigParameter(service, "QS.DynamicThesaurus.MaxThesaurusSize", 5);
}

private static int getMinClusterSize(PortalService service)
{
	return readIntConfigParameter(service, "QS.DynamicClustering.MinClusterSize", 5);
}

private static int getNumClusterResults(PortalService service)
{
	return readIntConfigParameter(service, "QS.MaxResults", 250);
}

private static int getMinNumDocsForSubClustering(PortalService service)
{
	int minNumDocs = readIntConfigParameter(service, "QS.DynamicClustering.MinClusterSizeToCheck", 15);
	// If a cluster is smaller than twice the minimum cluster size then there's no way it can be split into two...
	int minCluSize = getMinClusterSize(service);
	if(2 * minCluSize > minNumDocs)
	{
		minNumDocs = 2 * minCluSize;
	}
	return minNumDocs;
}

private static int getMaxNumDocsForSubClustering(PortalService service)
{
	return readIntConfigParameter(service, "QS.DynamicClustering.MaxClusterSizeToCheck", 40);
}

private static int getMaxClusterDepth(PortalService service)
{
	return readIntConfigParameter(service, "QS.QuerySummary.Depth", 2);
}

private static int getMaxNumAQGClusters(PortalService service)
{
	return readIntConfigParameter(service, "QS.AQG.MaxNumberOfClusters", 3);
}

private static int getMaxAQGClusterSize(PortalService service)
{
	return readIntConfigParameter(service, "QS.AQG.MaxClusterSize", 3);
}

private static int getMaxIdeasCloudDroplets(PortalService service)
{
	return readIntConfigParameter(service, "QS.IdeasCloud.MaxDroplets", 25);
}

// Convenience method to get int config settings
private static int readIntConfigParameter(PortalService service, String name, int defaultValue)
{
	String sVal = service.readConfigParameter(name, defaultValue + "");

	try
	{
		defaultValue = Integer.parseInt(sVal);
	}
	catch(Exception e)
	{
	}

	return defaultValue;
}

private static String getRequestParam(PortalService service, String paramName)
{
	return service.getSafeRequestParameter(service.makeParameterName(paramName), "").trim();
}

// Convenience method to add an ActionParameter to an ArrayList, replacing an existing ActionParameter if necessary
private static void replaceActionParameter(ArrayList parameters, String name, String value)
{
	if(parameters != null && name != null && value != null)
	{
		for(int nLoop = 0 ; nLoop < parameters.size() ; nLoop++)
		{
			ActionParameter ap = (ActionParameter)parameters.get(nLoop);

			if(ap.getName().equalsIgnoreCase(name))
			{
				ap.setValue(value);
				return;
			}
		}

		parameters.add(new ActionParameter(name, value));
	}
}

private static void replaceActionParameter(ArrayList parameters, String name, int value)
{
	replaceActionParameter(parameters, name, value + "");
}

// Returns the query summary type
private static String getBrowsingType(PortalService service)
{
	String browsingType = service.readConfigParameter("QuerySummaryType", null);

	if(browsingType == null)
	{
		// Old config parameter name
		browsingType = service.readConfigParameter("ResultBrowsingType", "");
	}

	return browsingType;
}

private static void setError(PortalService service, String sErrorMess)
{
	if(service != null && StringUtils.strValid(sErrorMess))
	{
		// append any existing error message
		String sCurrentError = (String)service.getSessionAttribute(RetrievalConstants.SESSION_ATTRIB_ERROR_MESSAGE);
		if(StringUtils.strValid(sCurrentError))
		{
			sErrorMess = sCurrentError + "<br />" + sErrorMess;
		}
		service.setSessionAttribute(RetrievalConstants.SESSION_ATTRIB_ERROR_MESSAGE, sErrorMess);
	}
}

%>